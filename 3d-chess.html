<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Mountain Chessboard</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- Include Three.js and chess.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <script>
    // Initialize scene, camera, and renderer
    const scene = new THREE.Scene();
    
    // Create soft pink to orange gradient background
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 512;
    canvas.height = 512;
    const gradient = context.createLinearGradient(0, 0, 0, 512);
    gradient.addColorStop(0, '#ffd4d4'); // soft pink
    gradient.addColorStop(1, '#ffe4cc'); // soft orange
    context.fillStyle = gradient;
    context.fillRect(0, 0, 512, 512);
    const backgroundTexture = new THREE.CanvasTexture(canvas);
    scene.background = backgroundTexture;
    
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 25, 35);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Add orbit controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enablePan = false;
    controls.minDistance = 15;
    controls.maxDistance = 60;
    controls.maxPolarAngle = Math.PI / 2;

    // Add ambient and directional light
    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(20, 30, 20);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);

    // Create the semi-transparent mountain-like chessboard
    const boardGroup = new THREE.Group();
    const squareSize = 2;
    const boardSize = 8;
    const squares = [];
    
    for (let i = 0; i < boardSize; i++) {
      squares[i] = [];
      for (let j = 0; j < boardSize; j++) {
        const geometry = new THREE.BoxGeometry(squareSize * 0.95, 0.3, squareSize * 0.95);
        const isLight = (i + j) % 2 === 0;
        const material = new THREE.MeshPhongMaterial({
          color: isLight ? 0xf0f0f0 : 0xa0a0a0,
          transparent: true,
          opacity: 0.7,
        });
        const square = new THREE.Mesh(geometry, material);
        const x = (i - boardSize / 2 + 0.5) * squareSize;
        const z = (j - boardSize / 2 + 0.5) * squareSize;
        
        // Create mountain peak with 4 levels based on distance from center
        const centerX = 3.5;
        const centerZ = 3.5;
        const distanceFromCenter = Math.max(Math.abs(i - centerX), Math.abs(j - centerZ));
        let elevation;
        
        if (distanceFromCenter < 1.0) { // Center 4 squares (highest)
          elevation = 6.0;
        } else if (distanceFromCenter < 2.0) { // Next ring
          elevation = 4.0;
        } else if (distanceFromCenter < 3.0) { // Third ring
          elevation = 2.0;
        } else { // Outer ring (lowest)
          elevation = 0.0;
        }
        
        square.position.set(x, elevation, z);
        square.receiveShadow = true;
        squares[i][j] = { mesh: square, elevation: elevation };
        boardGroup.add(square);
      }
    }
    scene.add(boardGroup);

    // Initialize chess.js
    const chess = new Chess();

    // Chess piece symbols mapping
    const pieceSymbols = {
      'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚',
      'P': '♙', 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔'
    };

    // Create chess pieces using simple geometry with symbols
    function createPieces() {
      const pieceGroup = new THREE.Group();
      const position = chess.board();
      
      for (let rank = 0; rank < boardSize; rank++) {
        for (let file = 0; file < boardSize; file++) {
          const piece = position[rank][file];
          if (piece) {
            // Create piece base
            const baseGeometry = new THREE.CylinderGeometry(0.4, 0.5, 0.8, 12);
            const baseMaterial = new THREE.MeshPhongMaterial({
              color: piece.color === 'w' ? 0xffffff : 0x222222,
            });
            const baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
            
            // Position on board
            const x = (file - boardSize / 2 + 0.5) * squareSize;
            const z = (rank - boardSize / 2 + 0.5) * squareSize;
            const elevation = squares[file][rank].elevation;
            
            baseMesh.position.set(x, elevation + 0.8, z);
            baseMesh.castShadow = true;
            
            // Create text sprite for piece symbol
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 128;
            context.font = 'Bold 80px Arial';
            context.fillStyle = piece.color === 'w' ? '#000000' : '#ffffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(pieceSymbols[piece.type] || piece.type.toUpperCase(), 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, elevation + 2.2, z);
            sprite.scale.set(1.5, 1.5, 1);
            
            pieceGroup.add(baseMesh);
            pieceGroup.add(sprite);
          }
        }
      }
      scene.add(pieceGroup);
    }

    // Create pieces after scene is ready
    createPieces();

    // Handle window resize
    window.addEventListener('resize', function () {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }, false);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>